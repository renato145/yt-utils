# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_core.ipynb.

# %% auto 0
__all__ = ['YTVideo', 'SubtitleEntry', 'Subtitles', 'YTPlaylist']

# %% ../nbs/00_core.ipynb 2
from fastcore.all import *
from yt_dlp import YoutubeDL
import json, datetime, httpx

# %% ../nbs/00_core.ipynb 6
class YTVideo:
    def __init__(self, data:dict):
        store_attr()
        self.subtitles,self.chapters = None,None
    
    def __repr__(self):
        flds = ['webpage_url','title','language','uploader','categories','tags']
        flds = [f'{o}={self.data[o]!r}' for o in flds if o in self.data]
        if 'duration' in self.data: flds.append(f'duration={datetime.timedelta(seconds=self.data["duration"])}')
        for o in ['automatic_captions','subtitles','chapters','heatmap']: flds.append(f'have_{o}={o in self.data}')
        sig = ', '.join(flds)
        return f'YTVideo({sig})'

# %% ../nbs/00_core.ipynb 7
@patch(cls_method=True)
def from_url(cls:YTVideo, url:str, quiet:bool=True)->YTVideo:
    opts = {
        'writedescription':True, 'writesubtitles':True, 'writeautomaticsub':True, 'no_warnings':True, 'skip_download':True,
        'subtitlesformat':'srt', 'quiet':quiet,
    }
    with YoutubeDL(opts) as ydl:
        data = ydl.extract_info(url, download=False)
        return YTVideo(data)

# %% ../nbs/00_core.ipynb 10
@patch
def subtitles_url(self:YTVideo, lang:str=None):
    lang = ifnone(lang, self.data.get('language'))
    d = self.data.get('subtitles', self.data.get('automatic_captions'))
    if d is None: return
    if lang not in d: lang = list(d.keys())[0]
    return next(o['url'] for o in d[lang] if o['ext']=='srt')

# %% ../nbs/00_core.ipynb 14
_subtitle_entry_pat = re.compile(r'(\d+)\n(\d+:\d+:\d+),\d+ --> (\d+:\d+:\d+),\d+\n(.+)', re.DOTALL)

class SubtitleEntry:
    __repr__ = basic_repr()
    def __init__(self, index:int, start:datetime.timedelta, end:datetime.timedelta, text:str): store_attr()

    @classmethod
    def from_str(cls, s:str)->'Self':
        if s.count('\n')<2: return None
        match = _subtitle_entry_pat.match(s.strip())
        text = re.sub(r'[\n\xa0]+', ' ', match.group(4))
        return cls(int(match.group(1)), match.group(2), match.group(3), text)

# %% ../nbs/00_core.ipynb 16
class Subtitles:
    def __init__(self, entries:L): store_attr()

    def __repr__(self):
        sig = ', '.join([f'entries={len(self.entries)}', f'last_ts={self.entries[-1].end!r}'])
        return f'Subtitles({sig})'

    @classmethod
    def from_str(cls, s:str)->'Self': 
        entries = L.split(s.strip(), '\n\n').map(SubtitleEntry.from_str).filter()
        return cls(entries)

# %% ../nbs/00_core.ipynb 18
@patch(cls_method=True)
def from_url(cls:Subtitles, url:str)->Subtitles: return cls.from_str(httpx.get(url).text)

# %% ../nbs/00_core.ipynb 20
@patch
def format_subs(self:Subtitles)->str:
    "Formats subtitles to use in LLMs."
    return '\n'.join(self.entries.map(lambda o: f'[{o.start}] {o.text}'))

# %% ../nbs/00_core.ipynb 22
@patch
@delegates(YTVideo.subtitles_url)
def fetch_subtitles(self:YTVideo, force:bool=False, **kwargs)->YTVideo:
    if force or (self.subtitles is None): self.subtitles = Subtitles.from_url(self.subtitles_url(**kwargs))
    return self

# %% ../nbs/00_core.ipynb 24
@patch
@delegates(YTVideo.fetch_subtitles)
def format_subs(self:YTVideo, **kwargs)->str:
    self.fetch_subtitles(**kwargs)
    if self.subtitles is None: return
    return self.subtitles.format_subs()

# %% ../nbs/00_core.ipynb 27
def _format_chapter(s:dict)->str:
    start = datetime.timedelta(seconds=s['start_time'])
    return f'[{start}] {s["title"]}'

# %% ../nbs/00_core.ipynb 29
@patch
def format_chapters(self:YTVideo)->str:
    if self.data.get('chapters') is None: return
    return '\n'.join(map(_format_chapter, self.data['chapters']))

# %% ../nbs/00_core.ipynb 32
@patch
@delegates(YTVideo.fetch_subtitles)
def create_summary_prompt(self:YTVideo, user_prompt:str=None, **kwargs)->str:
    self.fetch_subtitles(**kwargs)
    transcript = self.format_subs()
    if transcript is None: return
    description = self.data.get('description')
    chapters = self.format_chapters()
    prompt = f'''In the <transcript> tag we have transcript of a video with the title: {self.data['title']!r}. \
Analyse the transcript to generate a detailed summary of the content of the video.

Your task:
<task>
1. Start with a 2-3 sentence overview of the entire video.
2. Identify chapters, where major topics begin and end.
3. Summarise each chapter's key concepts in no more than 15 bullet points. The summary should have very high information value.
4. Extract all resources mentioned, e.g. links, books, papers, videos, YouTube channels etc.
</task>

Format your response in Markdown:
<format>
- Start with "## Overview" followed by the 2-3 sentence summary
- For each chapter use: "## [Chapter Title] - HH:MM:SS", e.g.: "## Introduction - 00:02:30"
- Follow each chapter heading with bullet points
- End with a "## Resources" section containing a list of the resources mentioned through the video, including a brief context.
<format>

Here is the transcript with timestamps:
<transcript>
{transcript}
</transcript>'''

    if description is not None:
        prompt += f'''

Here is the video description:
<video-description>
{description}
</video-description>
'''

    if chapters is not None:
        prompt += f'''

Incase it is helpful, here are the chapters defined in the video. However, please use timestamps from the transcript when possible. 
<video-chapters>
{chapters}
</video-chapters>
'''

    if user_prompt is not None:
        prompt += f"\n\nAdditional context/instructions from the user:\n<user-context>\n{user_prompt}\n</user-context>"

    prompt += '\n\nPlease go ahead and write the detailed summary of the video and the summary of each chapter you find.'
    return prompt

# %% ../nbs/00_core.ipynb 36
class YTPlaylist:
    def __init__(self, data:dict): store_attr()
    def __repr__(self):
        flds = ['webpage_url', 'title', 'channel', 'playlist_count']
        sig = ', '.join(f'{o}={self.data[o]!r}' for o in flds)
        return f'YTPlaylist({sig})'

# %% ../nbs/00_core.ipynb 37
@patch(cls_method=True)
def from_url(cls:YTPlaylist, url:str, quiet:bool=True)->YTPlaylist:
    with YoutubeDL({'flat_playlist':True, 'extract_flat':True, 'quiet':quiet}) as ydl:
        data = ydl.extract_info(url, download=False)
        return YTPlaylist(data)

# %% ../nbs/00_core.ipynb 40
@patch
@delegates(YTVideo.from_url)
def get_videos(self:YTPlaylist, n_workers=4, progress=False, **kwargs)->L:
    entries = L(self.data['entries']).itemgot('url').filter()
    return parallel(partial(YTVideo.from_url, **kwargs), entries, threadpool=True, n_workers=n_workers, progress=progress)
