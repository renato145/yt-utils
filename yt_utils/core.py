# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_core.ipynb.

# %% auto 0
__all__ = ['YTVideo', 'SubtitleEntry', 'Subtitles', 'YTPlaylist']

# %% ../nbs/00_core.ipynb 2
from fastcore.all import *
from yt_dlp import YoutubeDL
import json, datetime, httpx

# %% ../nbs/00_core.ipynb 6
class YTVideo:
    def __init__(self, data:dict):
        store_attr()
        self.subtitles,self.chapters = None,None
    
    def __repr__(self):
        flds = ['webpage_url','title','language','uploader','categories','tags']
        flds = [f'{o}={self.data[o]!r}' for o in flds if o in self.data]
        if 'duration' in self.data: flds.append(f'duration={datetime.timedelta(seconds=self.data["duration"])}')
        for o in ['automatic_captions','subtitles','chapters','heatmap']: flds.append(f'have_{o}={o in self.data}')
        sig = ', '.join(flds)
        return f'YTVideo({sig})'

# %% ../nbs/00_core.ipynb 7
@patch(cls_method=True)
def from_url(cls:YTVideo, url:str, quiet:bool=True)->YTVideo:
    opts = {
        'writedescription':True, 'writesubtitles':True, 'writeautomaticsub':True, 'no_warnings':True, 'skip_download':True,
        'subtitlesformat':'srt', 'quiet':quiet,
    }
    with YoutubeDL(opts) as ydl:
        data = ydl.extract_info(url, download=False)
        return YTVideo(data)

# %% ../nbs/00_core.ipynb 9
@patch
def subtitles_url(self:YTVideo, language:str=None):
    lang = ifnone(language, self.data.get('language'))
    d = self.data.get('subtitles', self.data.get('automatic_captions'))
    if d is None: return
    return next(o['url'] for o in d[lang] if o['ext']=='srt')

# %% ../nbs/00_core.ipynb 13
_subtitle_entry_pat = re.compile(r'(\d+)\n(\d+:\d+:\d+),\d+ --> (\d+:\d+:\d+),\d+\n(.+)', re.DOTALL)

class SubtitleEntry:
    __repr__ = basic_repr()
    def __init__(self, index:int, start:datetime.timedelta, end:datetime.timedelta, text:str): store_attr()

    @classmethod
    def from_str(cls, s:str)->'Self':
        if s.count('\n')<2: return None
        match = _subtitle_entry_pat.match(s.strip())
        text = re.sub(r'[\n\xa0]+', '\n', match.group(4))
        return cls(int(match.group(1)), match.group(2), match.group(3), text)

# %% ../nbs/00_core.ipynb 15
class Subtitles:
    def __init__(self, entries:L): store_attr()

    def __repr__(self):
        sig = ', '.join([f'entries={len(self.entries)}', f'last_ts={self.entries[-1].end!r}'])
        return f'Subtitles({sig})'

    @classmethod
    def from_str(cls, s:str)->'Self': 
        entries = L.split(s.strip(), '\n\n').map(SubtitleEntry.from_str).filter()
        return cls(entries)

# %% ../nbs/00_core.ipynb 17
@patch(cls_method=True)
def from_url(cls:Subtitles, url:str)->Subtitles: return cls.from_str(httpx.get(url).text)

# %% ../nbs/00_core.ipynb 19
@patch
def format_subs(self:Subtitles)->str:
    "Formats subtitles to use in LLMs."
    return '\n'.join(self.entries.map(lambda o: f'[{o.start}] {o.text}'))

# %% ../nbs/00_core.ipynb 21
@patch
@delegates(YTVideo.subtitles_url)
def fetch_subtitles(self:YTVideo, force:bool=False, **kwargs)->YTVideo:
    if force or (self.subtitles is None): self.subtitles = Subtitles.from_url(self.subtitles_url(**kwargs))
    return self

# %% ../nbs/00_core.ipynb 23
def _format_chapter(s:dict)->str:
    start = datetime.timedelta(seconds=s['start_time'])
    return f'[{start}] {s["title"]}'

# %% ../nbs/00_core.ipynb 25
@patch
def format_chapters(self:YTVideo)->str:
    return '\n'.join(map(_format_chapter, self.data['chapters']))

# %% ../nbs/00_core.ipynb 29
class YTPlaylist:
    def __init__(self, data:dict): store_attr()
    def __repr__(self):
        flds = ['webpage_url', 'title', 'channel', 'playlist_count']
        sig = ', '.join(f'{o}={self.data[o]!r}' for o in flds)
        return f'YTPlaylist({sig})'

# %% ../nbs/00_core.ipynb 30
@patch(cls_method=True)
def from_url(cls:YTPlaylist, url:str, quiet:bool=True)->YTPlaylist:
    with YoutubeDL({'flat_playlist':True, 'extract_flat':True, 'quiet':quiet}) as ydl:
        data = ydl.extract_info(url, download=False)
        return YTPlaylist(data)
